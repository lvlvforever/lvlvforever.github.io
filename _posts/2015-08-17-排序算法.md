---
layout: post
title: 常见排序算法总结
categories: algorithm-sort
tags: sort
---
###排序依赖的方法和数据结构
####1 交换和比较
#####1) 使用一个临时元素保存中间值，空间复杂度是O(1)。
{% highlight java linenos %}
private void swap(int[] nums,int i ,int j){
		if(i == j) return;
		if(nums[i] == nums[j]) return;
		int tmp = nums[i];
		nums[i] = nums[j];
		nums[j] = tmp;
	}
{% endhighlight java %}
#####2) 不使用临时元素,但需要注意当i==j时会出错，所以需要先处理这种情况。
{% highlight java linenos %}
 private void swap(int[] nums,int i, int j){
	 		if(i == j) return;
	 		if(nums[i] == nums[j]) return;
	    	nums[i] ^= nums[j];
	    	nums[j] ^= nums[i];
	    	nums[i] ^= nums[j];
	    }
{% endhighlight java %}
#####3) 比较大小
{% highlight java linenos %}
 private boolean less(int[] a, int i, int j){
	 	return a[i] < a[j];
	 }
{% endhighlight java %}
####2 链表结构
{% highlight java linenos %}
public class ListNode {
      int val;
      ListNode next;
      ListNode(int x) { val = x; }
      ListNode(){}
 }
{% endhighlight java %}
###2 选择排序
每次从剩余元素选择一个最小的，排在当前位置.
{% highlight java linenos %}
	 public void selectionSort(int[] nums){
	 	if(nums == null || nums.length <= 1) return;
	 	int n = nums.length;
	 	for(int i = 1; i < n; i++){
	 		int min = i;
	 		for(int j = i+1; j < n; j++){
	 			if(less(nums,j,min)) min = j;
	 		}
	 		swap(nums,i,min);
	 	}
	 }
{% endhighlight java %}
###3 插入排序
####1 数组
每次都把一个元素插入到已经有序的序列里。
{% highlight java linenos %}
 public void insertionSort(int[] nums){
	 	if(nums == null || nums.length <= 1) return;
	 	int n = nums.length;
	 	//i之前的已经有序
	 	for(int i = 1; i < n ; i++){
	 		for(int j = i; j >= 1 && less(nums,j,j-1); j--){
	 			swap(nums,j,j-1);
	 		}
	 	}
	 }
{% endhighlight java %}
####2 链表
{% highlight java linenos %}
public ListNode insertionSort(ListNode head){
		if(head == null || head.next == null) return head;
		ListNode dummyHead = new ListNode();
		ListNode pre;
		while(head != null){
			pre = dummyHead;
			while(pre.next != null && pre.next.val < head.val){
				pre = pre.next;
			}
			ListNode tmp = head.next;
			head.next = pre.next;
			pre.next = head;
			head = tmp;
		}
		return dummyHead.next;
	}
{% endhighlight java %}
###4 希尔排序
选择的序列h = 1,4,13,40....<br>
希尔排序可以这样理解，每次排序间隔为h的元素。<br>
比如<br>
0 1 2 3 4 5 6 7 8 9 10<br>
h = 4 时：排序0 4 8,1 5 9, 2 6 10, 3 7<br>
h = 1 时 排序 0 1 2 3 4 5 6 7 8 9 10<br>
代码可以更清晰的表现出希尔排序和插入排序的关系。<br>
仔细比较可以看出，插入排序仅仅是希尔排序当h=1时的特殊情况。
{% highlight java linenos %}
public void shellSort(int[] nums){
	 	if(nums == null || nums.length <= 1) return;
		int n = nums.length;
		int h = 1;
		while(h < n / 3) h = 3 * h + 1;
		while(h >= 1){
			for(int i = h; i < n; i++){
				for(int j = i; j >= h && less(nums,j,j-h); j-=h){
					swap(nums,j,j-h);
				}
			}
			h = h / 3;
		}	 	
	 }
{% endhighlight java %}
###5 快速排序
每趟排序时选定一个元素，将小于该元素的放在元素左边，大于该元素的放在右边，然后
递归的处理左右两边。
{% highlight java linenos %}
public void quickSort(int[] nums){
	 	if(nums == null || nums.length <= 1) return;
	 	int hi = nums.length - 1;
	 	quickSort(nums,0,hi);
	 }
	 private void quickSort(int[] nums,int lo,int hi){
	 	if(lo >= hi) return;
	 	int mid = lo + (hi - lo) / 2;
	 	int j = partition(nums,lo,hi);
	 	quickSort(nums,lo,j-1);
	 	quickSort(nums,j+1,hi);
	 }
	 private int partition(int[] nums,int lo,int hi){
	 	int i = lo;
	 	int j = hi+1;
	 	int v = nums[lo];
	 	while(true){
	 		while(less(nums,++i,lo)) if(i == hi) break;
	 		while(less(nums,lo,--j)) if(j == lo) break;
	 		if(i >= j) break;
	 		swap(nums,i,j);
	 	}
	 	swap(nums,lo,j);
	 	return j;
	 }
{% endhighlight java %}
###6 归并排序